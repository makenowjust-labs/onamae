package onamae

import scala.annotation.tailrec
import scala.collection.SortedSet
import scala.collection.mutable
import scala.compiletime.{erasedValue, summonAll, summonFrom, summonInline}
import scala.deriving.Mirror

/** Atom is a name in nominal elements.
  *
  * This value is represented by 32-bit signed integer value, and we assume that the value should be positive.
  * Thus, the maximal number of atoms is limited to `2 ** 31`, but it is not problematic in usually cases.
  */
final class Atom(private val id: Int) extends Ordered[Atom]:
  override def compare(that: Atom): Int = id.compare(that.id)

  override def equals(that: Any): Boolean = that match
    case atom: Atom => id == atom.id
    case _          => false

  override def hashCode(): Int = id.hashCode()

  override def toString(): String = s"Atom($id)"

/** Support is a support of nominal elements. */
final case class Support(toSortedSet: SortedSet[Atom]):

  /** Returns the size of `this` support. */
  def size: Int = toSortedSet.size

  /** Returns the first atom of `this` support. */
  def head: Atom = toSortedSet.head

  /** Returns the rest support of `this`. */
  def tail: Support = Support(toSortedSet.tail)

  /** Returns the union of `this` and `that` supports. */
  infix def union(that: Support): Support = Support(toSortedSet union that.toSortedSet)

  /** Returns the intersection of `this` and `that` supports. */
  infix def intersect(that: Support): Support = Support(toSortedSet intersect that.toSortedSet)

  /** Checks whether `this` is a subset of `that`. */
  def subsetOf(that: Support): Boolean = toSortedSet.subsetOf(that.toSortedSet)

  /** Returns a sequence of `this`. */
  def toSeq: Seq[Atom] = toSortedSet.toSeq

  override def toString(): String = toSortedSet.mkString("Support(", ", ", ")")

/** Support utilities. */
object Support:

  /** Returns the empty support. */
  def empty: Support = Support(SortedSet.empty[Atom])

  /** Constructs a support with the given `atoms`. */
  def apply(atoms: Atom*): Support = Support(SortedSet.from(atoms))

  /** Returns the default support with `0 until n` atoms. */
  def default(n: Int): Support = Support(SortedSet.from(0 until n).map(Atom(_)))

/** Key is a key to partition support atoms into sides of products. */
enum Key:
  case Left, Both, Right

/** Key utilities. */
object Key:
  private val productKeysMemo: mutable.Map[(Int, Int), Seq[Seq[Key]]] = mutable.Map.empty
  private val sepProductKeysMemo: mutable.Map[(Int, Int), Seq[Seq[Key]]] = mutable.Map.empty
  private val leftProductKeysMemo: mutable.Map[(Int, Int), Seq[Seq[Key]]] = mutable.Map.empty
  private val rightProductKeysMemo: mutable.Map[(Int, Int), Seq[Seq[Key]]] = mutable.Map.empty

  /** Returns a sequence of keys for a product of `n` and `m` dimension orbits. */
  def productKeys(n: Int, m: Int): Seq[Seq[Key]] =
    productKeysMemo.getOrElseUpdate(
      (n, m),
      (n, m) match
        case (0, 0) => Seq(Seq.empty)
        case (n, 0) => Seq(Seq.tabulate(n)(_ => Left))
        case (0, m) => Seq(Seq.tabulate(m)(_ => Right))
        case (1, 1) => Seq(Seq(Left, Right), Seq(Both), Seq(Right, Left))
        case (n, m) =>
          productKeys(n - 1, m).map(Left +: _) ++
            productKeys(n - 1, m - 1).map(Both +: _) ++
            productKeys(n, m - 1).map(Right +: _)
    )

  /** Like `Key.productKeys`, but these keys are separated. That is, a product generated by these keys has no
    * intersection of supports of both values.
    */
  def sepProductKeys(n: Int, m: Int): Seq[Seq[Key]] =
    sepProductKeysMemo.getOrElseUpdate(
      (n, m),
      (n, m) match
        case (0, 0) => Seq(Seq.empty)
        case (n, 0) => Seq(Seq.tabulate(n)(_ => Left))
        case (0, m) => Seq(Seq.tabulate(m)(_ => Right))
        case (1, 1) => Seq(Seq(Left, Right), Seq(Right, Left))
        case (n, m) =>
          sepProductKeys(n - 1, m).map(Left +: _) ++
            sepProductKeys(n, m - 1).map(Right +: _)
    )

  /** Like `Key.productKeys`, but it is for left products. */
  def leftProductKeys(n: Int, m: Int): Seq[Seq[Key]] =
    leftProductKeysMemo.getOrElseUpdate(
      (n, m),
      (n, m) match
        case (0, 0)          => Seq(Seq.empty)
        case (n, 0)          => Seq(Seq.tabulate(n)(_ => Left))
        case (1, 1)          => Seq(Seq(Both))
        case (n, m) if n < m => Seq.empty
        case (n, m) =>
          leftProductKeys(n - 1, m).map(Left +: _) ++
            leftProductKeys(n - 1, m - 1).map(Both +: _)
    )

  /** Like `Key.productKeys`, but it is for right products. */
  def rightProductKeys(n: Int, m: Int): Seq[Seq[Key]] =
    rightProductKeysMemo.getOrElseUpdate(
      (n, m),
      (n, m) match
        case (0, 0)          => Seq(Seq.empty)
        case (0, m)          => Seq(Seq.tabulate(m)(_ => Right))
        case (1, 1)          => Seq(Seq(Both))
        case (n, m) if n > m => Seq.empty
        case (n, m) =>
          rightProductKeys(n - 1, m - 1).map(Both +: _) ++
            rightProductKeys(n, m - 1).map(Right +: _)
    )

/** ProductOrbit is an orbit for product types. */
final case class ProductOrbit[A, B](orbitA: Nominal[A]#Orbit, orbitB: Nominal[B]#Orbit, keys: Seq[Key])

/** Nominal is a type-class for nominal elements.
  *
  * **Laws**:
  *
  * 1. `dim(orbitOf(x)) == support(x).size`
  * 2. `orbitOf(elementOf(o, s)) == o` (if `s.size == dim(o)`)
  * 3. `elementOf(orbitOf(x), support(x)) == x`
  */
trait Nominal[A]:

  /** A type of orbits of this nominal elements. */
  type Orbit

  /** Returns the orbit of `element`. */
  def orbitOf(element: A): Orbit

  /** Returns the support of `element`. */
  def support(element: A): Support

  /** Returns the elemet from `orbit` and `support`. */
  def elementOf(orbit: Orbit, support: Support): A

  /** Returns the dimension of `orbit`, i.e., ths size of the support of `orbit`. */
  def dim(orbit: Orbit): Int

  /** Returns the default element of `orbit`. */
  def defaultElementOf(orbit: Orbit): A =
    elementOf(orbit, Support.default(dim(orbit)))

/** Nominal utilities and default instances. */
object Nominal:

  /** Computes a sequence of orbits of `orbitA` and `orbitB` products.
    *
    * **Pseudo code**:
    *
    * ```scala
    * product(orbitA, orbitB) = for { a <- orbitA; b <- orbitB } yield orbitOf(a, b)
    * ```
    */
  def product[A, B](using A: Nominal[A], B: Nominal[B])(orbitA: A.Orbit, orbitB: B.Orbit): Seq[ProductOrbit[A, B]] =
    Key.productKeys(A.dim(orbitA), B.dim(orbitB)).map(ProductOrbit(orbitA, orbitB, _))

  /** Computes a sequence of orbits of `orbitA` and `orbitB` products separated by thier supports.
    *
    * **Pseudo code**:
    *
    * ```scala
    * sepProduct(orbitA, orbitB) = for {
    *   a <- orbitA; b <- orbitB
    *   if (support(a) intersect support(b)).isEmpty
    * } yield (a, b)
    * ```
    */
  def sepProduct[A, B](using A: Nominal[A], B: Nominal[B])(orbitA: A.Orbit, orbitB: B.Orbit): Seq[ProductOrbit[A, B]] =
    Key.sepProductKeys(A.dim(orbitA), B.dim(orbitB)).map(ProductOrbit(orbitA, orbitB, _))

  /** Computes a sequence of orbits of `orbitA` and `orbitB` left-products.
    *
    * **Pseudo code**:
    *
    * ```scala
    * leftProduct(orbitA, orbitB) = for {
    *   a <- orbitA; b <- orbitB
    *   if support(b).subsetOf(support(a))
    * } yield (a, b)
    * ```
    */
  def leftProduct[A, B](using A: Nominal[A], B: Nominal[B])(orbitA: A.Orbit, orbitB: B.Orbit): Seq[ProductOrbit[A, B]] =
    Key.leftProductKeys(A.dim(orbitA), B.dim(orbitB)).map(ProductOrbit(orbitA, orbitB, _))

  /** Computes a sequence of orbits of `orbitA` and `orbitB` right-products.
    *
    * **Pseudo code**:
    *
    * ```scala
    * rightProduct(orbitA, orbitB) = for {
    *   a <- orbitA; b <- orbitB
    *   if support(a).subsetOf(support(b))
    * } yield (a, b)
    * ```
    */
  def rightProduct[A, B](using
      A: Nominal[A],
      B: Nominal[B]
  )(orbitA: A.Orbit, orbitB: B.Orbit): Seq[ProductOrbit[A, B]] =
    Key.rightProductKeys(A.dim(orbitA), B.dim(orbitB)).map(ProductOrbit(orbitA, orbitB, _))

  /** Derives a trivial `Nominal` instance.
    *
    * This instance is useful when the group action is trivial. It means each element is its own orbit and
    * is supported by the empty set.
    *
    * **Example**:
    *
    * ```scala
    * case class Foo(x: Int, y: Int)
    *
    * given Nominal[Foo] = Nominal.derivedTrivially
    * ```
    */
  inline def derivedTrivially[A]: Nominal[A] = new TrivialNominalInstance

  final class TrivialNominalInstance[A] extends Nominal[A]:
    type Orbit = A
    def orbitOf(element: A): Orbit = element
    def support(element: A): Support = Support.empty
    def elementOf(orbit: Orbit, _support: Support): A = orbit
    def dim(_orbit: Orbit): Int = 0

  /** Derives a generic `Nominal` instance.
    *
    * This derives the right instance via `scala.deriving.Mirror` based on the algebraic data type.
    * This can also derive the instance even if the type has type parameters and/or is recursive.
    *
    * **Example**:
    *
    * ```scala
    * // `derives Nominal` uses `Nominal.derived` internally.
    * enum Foo[A] derives Nominal:
    *   case Bar(x: Int, y: Foo)
    *   case Baz(z: Int, w: A)
    * ```
    */
  inline def derived[A](using mirror: Mirror.Of[A]): Nominal[A] =
    inline mirror match
      case productMirror: Mirror.ProductOf[A] => derivedProduct(productMirror)
      case sumMirror: Mirror.SumOf[A]         => derivedSum(sumMirror)

  /** Derives a generic `Nominal` instance for `Product` types. */
  private inline def derivedProduct[A](mirror: Mirror.ProductOf[A]): Nominal[A] =
    val instance = summonInline[Nominal[mirror.MirroredElemTypes]].asInstanceOf[Nominal[Tuple]]
    new ProductNominalInstance(mirror, instance)

  final class ProductNominalInstance[A](val mirror: Mirror.ProductOf[A], val instance: Nominal[Tuple])
      extends Nominal[A]:
    def toTuple(element: A): Tuple = Tuple.fromProduct(element.asInstanceOf[Product])
    type Orbit = instance.Orbit
    def orbitOf(element: A): Orbit = instance.orbitOf(toTuple(element))
    def support(element: A): Support = instance.support(toTuple(element))
    def elementOf(orbit: Orbit, support: Support): A = mirror.fromProduct(instance.elementOf(orbit, support))
    def dim(orbit: Orbit): Int = instance.dim(orbit)

  /** Derives a generic `Nominal` instance for `Sum` types. */
  private inline def derivedSum[A](mirror: Mirror.SumOf[A]): Nominal[A] =
    val instances = derivedAll[mirror.MirroredElemTypes]
    new SumNominalInstance(mirror, instances)

  private inline def derivedAll[T <: Tuple]: Tuple.Map[T, Nominal] =
    inline erasedValue[T] match
      case _: EmptyTuple => EmptyTuple
      case _: (t *: ts) =>
        derived[t](using summonInline[Mirror.Of[t]]) *: derivedAll[ts]

  final class SumNominalInstance[A](
      val mirror: Mirror.SumOf[A],
      val instances: Tuple.Map[mirror.MirroredElemTypes, Nominal]
  ) extends Nominal[A]:
    type NominalAux[O] = Nominal[?] { type Orbit = O }
    type OrbitOf[N] = N match { case NominalAux[o] => o }
    type SumOfInstancesOrbit = Tuple.Union[Tuple.Map[instances.type, OrbitOf]]

    def instance(ord: Int): Nominal[A] = instances.productElement(ord).asInstanceOf[Nominal[A]]

    type Orbit = (Int, SumOfInstancesOrbit)

    def orbitOf(element: A): Orbit =
      val ord = mirror.ordinal(element)
      (ord, instance(ord).orbitOf(element).asInstanceOf[SumOfInstancesOrbit])
    def support(element: A): Support =
      val ord = mirror.ordinal(element)
      instance(ord).support(element)
    def elementOf(orbit: (Int, SumOfInstancesOrbit), support: Support): A =
      val (ord, o) = orbit
      val i = instance(ord)
      i.elementOf(o.asInstanceOf[i.Orbit], support)
    def dim(orbit: (Int, SumOfInstancesOrbit)): Int =
      val (ord, o) = orbit
      val i = instance(ord)
      i.dim(o.asInstanceOf[i.Orbit])

  // Standard instances:

  given atomNominalInstance: Nominal[Atom] with
    type Orbit = Unit
    def orbitOf(_element: Atom): Orbit = ()
    def support(element: Atom): Support = Support(element)
    def elementOf(_orbit: Unit, support: Support): Atom = support.head
    def dim(_orbit: Unit): Int = 1

  given supportNominalInstance: Nominal[Support] with
    type Orbit = Int
    def orbitOf(element: Support): Orbit = element.size
    def support(element: Support): Support = element
    def elementOf(_orbit: Int, support: Support): Support = support
    def dim(orbit: Int): Int = orbit

  // `Tuple` Instances:

  given emptyTupleNominalInstance: Nominal[EmptyTuple.type] = Nominal.derivedTrivially

  given tuple1NominalInstance[A](using A: Nominal[A]): Nominal[A *: EmptyTuple] with
    type Orbit = A.Orbit

    def orbitOf(element: A *: EmptyTuple): Orbit =
      val head *: _ = element
      A.orbitOf(head)
    def support(element: A *: EmptyTuple): Support =
      val head *: _ = element
      A.support(head)
    def elementOf(orbit: Orbit, support: Support): A *: EmptyTuple =
      A.elementOf(orbit, support) *: EmptyTuple
    def dim(orbit: Orbit): Int = A.dim(orbit)

  given nonEmptyTupleNominalInstance[A, B <: Tuple](using A0: => Nominal[A], B0: => Nominal[B]): Nominal[A *: B] with
    // `A0` and `B0` are by-name parameters because of preventing recursive expansions, and to refer them in types,
    // we need them to let in `final lazy val`.
    final lazy val A = A0
    final lazy val B = B0

    type Orbit = ProductOrbit[A, B]

    def orbitOf(element: A *: B): Orbit =
      def keys(supportA: Support, supportB: Support): Seq[Key] =
        @tailrec
        def loop(ls: Seq[Atom], rs: Seq[Atom], keys: Seq[Key]): Seq[Key] = (ls, rs) match
          case (ls, Seq())                 => ls.map(_ => Key.Left) ++ keys
          case (Seq(), rs)                 => rs.map(_ => Key.Right) ++ keys
          case (l +: ls, r +: rs) if l < r => loop(ls, r +: rs, Key.Left +: keys)
          case (l +: ls, r +: rs) if l > r => loop(l +: ls, rs, Key.Right +: keys)
          case (_ +: ls, _ +: rs)          => loop(ls, rs, Key.Both +: keys)
        loop(supportA.toSeq, supportB.toSeq, Seq.empty).reverse

      val head *: tail = element
      ProductOrbit(
        A.orbitOf(head),
        B.orbitOf(tail),
        keys(A.support(head), B.support(tail))
      )

    def support(element: A *: B): Support =
      val head *: tail = element
      A.support(head) union B.support(tail)

    def elementOf(orbit: Orbit, support: Support): A *: B =
      val ls = SortedSet.newBuilder[Atom]
      val rs = SortedSet.newBuilder[Atom]
      for (key, atom) <- orbit.keys.zip(support.toSeq) do
        key match
          case Key.Left  => ls.addOne(atom)
          case Key.Right => rs.addOne(atom)
          case Key.Both =>
            ls.addOne(atom)
            rs.addOne(atom)
      val head = A.elementOf(orbit.orbitA.asInstanceOf[A.Orbit], Support(ls.result()))
      val tail = B.elementOf(orbit.orbitB.asInstanceOf[B.Orbit], Support(rs.result()))
      head *: tail

    def dim(orbit: Orbit): Int = orbit.keys.size

  // Trivial instances:

  given booleanNominalInstance: Nominal[Boolean] = Nominal.derivedTrivially
  given charNominalInstance: Nominal[Char] = Nominal.derivedTrivially
  given byteNominalInstance: Nominal[Byte] = Nominal.derivedTrivially
  given shortNominalInstance: Nominal[Short] = Nominal.derivedTrivially
  given intNominalInstance: Nominal[Int] = Nominal.derivedTrivially
  given longNominalInstance: Nominal[Long] = Nominal.derivedTrivially

  // Generic instances:

  given optionNominalInstance[A: Nominal]: Nominal[Option[A]] = Nominal.derived
  given listNominalInstance[A: Nominal]: Nominal[List[A]] = Nominal.derived
  given eitherNominalInstance[A: Nominal, B: Nominal]: Nominal[Either[A, B]] = Nominal.derived
